---
title: "CursorからZedに乗り換えた — ビルトインAIを切って「黒い画面」に振り切った設定と理由"
emoji: "⚡"
type: "tech"
topics: ["zed", "claudecode", "cursor", "ai", "エディタ"]
published: true
---

# CursorからZedへ。迷走と発見の記録

2026年2月11日、私はCursorを捨ててZedに乗り換えました。

正確に言うと、「乗り換えようとして迷走し、最終的に想定外の最適解にたどり着いた」1日でした。この記事はその悪戦苦闘と、最終的に落ち着いた設定の全記録です。

## 前提：私はコードを書かない開発者です

まず前提を共有させてください。私は個人開発者ですが、**コードを一切書きません**。Claude Code（Anthropicが提供するCLIエージェント）にすべて任せています。

私の開発フローはこうです。

1. エディタでコードを **読む**（レビュー）
2. ターミナルでClaude Codeに **指示を出す**
3. 生成されたコードを **確認する**

つまりエディタに求めるのは「高速に表示すること」だけです。コード補完もスニペットもいりません。

この前提が、今日の迷走を引き起こし、同時に最適解への鍵になりました。

## 動機：「重い器に、軽い中身」の違和感

[Everything Claude Code (ECC)](https://github.com/anthropics/ecc) — 私が日常的に使っているClaude Codeの設定コレクションです。その開発者がZedを使っているのを見て、前から気になっていました。

Cursorは機能が豊富ですが、重い。起動に時間がかかるし、バックグラウンドでインデックスを作り続けてメモリを食います。しかも私はCursorの独自AI機能（Tab補完やComposer）を一切使わず、Claude Codeの拡張機能だけを動かしている状態でした。

つまり **「重い器に、軽い中身」**。無駄の塊です。

この違和感を解消するため、Geminiに相談したところ、衝撃的な指摘をされました。

> Cursorという重い器を使って、中身はVS Code用のClaude拡張を動かしている状態ですよね。CursorのAI機能を使わないなら、ただ重いだけです。

痛いところを突かれました。さらにGeminiはこう続けます。

> Zedは最初からエディタの機能として「Assistant Panel」が組み込まれています。APIキーを入れるだけで、拡張機能なしでClaudeが使えます。

なるほど。ZedはネイティブでクラウドベースのAI対応を持っていて、しかも動作が軽い。「後でClaude Codeに環境を作らせてみよう」 — そう決めた瞬間から、悪戦苦闘が始まりました。

## Zedとは何か（30秒で分かる概要）

具体的な話に入る前に、Zedの概要を簡単に整理しておきます。

Zedは **Rust製・GPU加速の高速エディタ** です。元Atom/Tree-sitterチームが開発しており、2026年春に1.0正式リリースを予定しています。

| 指標 | Zed | VSCode | 差 |
|:---|:---|:---|:---|
| 起動時間 | 0.12秒 | 1.2秒 | **10倍高速** |
| 大規模プロジェクト起動 | 0.25秒 | 3.8秒 | **15倍高速** |
| メモリ使用量 | 142MB | 730MB | **80%削減** |

この数字だけでも移行の動機としては十分ですが、実際に使ってみると体感がまったく違います。ファイルを開く、タブを切り替える、検索する — すべてが一瞬です。

## 第1の壁：インストールしたけど、何をすればいいのかわからない

Claude Codeに `settings.json` を書かせて、Zedのインストールは一瞬で終わりました。問題はその先です。

**Zedを開いたけど、何をすればいいのかわからない。**

Cursorなら左サイドバーにChatパネルがあって、そこに話しかければよかった。Zedにはそれに相当するものが見当たりません。

Geminiに聞いて、`Cmd + ?` でAssistant Panelが開くことを知りました。開いてみると、右側にチャット画面が現れます。そこでClaude Codeを選択し、`/login` で認証を通す — CursorのようにGUIでポチポチ設定する世界とは勝手が違いますが、手順自体はシンプルでした。

## 第2の壁：Agent Panelのブラックボックス問題

Assistant PanelでClaude Code（Agent）を選択すると、Cursorと同じようにチャットベースでAIに指示を出せます。ファイル作成もコマンド実行も自律的にやってくれます。

**しかし、コンテキストの消費量が表示されない。**

Cursorならコンテキスト使用率がバーで可視化されます。Zedにはそれがありません。Geminiに確認したところ、これはZedの仕様上の制限でした。

> Claude Code（ACP接続）のトークン消費量は、ZedのAgent Panelでは表示されません。外部エージェント連携では、この機能はサポートされていません。

コンテキストの残量がわからないまま作業するのは、ガソリンメーターのない車を運転するようなものです。

「Cursorなら見れるから、Cursorの方がいい気がしてきた。ただZedすごいさくさくなんだよなあ…」

この葛藤が、今日のターニングポイントになりました。

## 転機：「標準モード」に逃げるな

「じゃあ標準モード（APIを直接叩くモード）を使えばいいのか？」

一瞬そう思いましたが、Geminiに止められました。

> 標準モードにすると、Claudeは「こう書けば直りますよ」とテキストを表示するだけになります。ファイル作成もコマンド実行も自動ではやりません。

| 機能 | Agent Panel（Claude Code） | 標準モード |
|:---|:---|:---|
| コード修正 | 自動でファイルを書き換え | コード提示のみ（手動コピペ） |
| コマンド実行 | 自動でテスト・インストール実行 | 不可 |
| ファイル作成 | 自動 | 不可 |
| トークン表示 | **非表示** | **表示あり** |

「コードを書かない」私にとって、標準モードは致命的です。AIが提示するだけで自分でコピペしないといけない — それは一番やりたくないことです。

## 最適解の発見：CLIをZedに住まわせる

この膠着状態を打破したのは、Geminiの一言でした。

> ZedのAgent Panelを使わず、Zedのターミナルで `claude` を実行するという手があります。

目から鱗でした。

**Zedの中のターミナルでClaude Code CLIを起動する。** これなら：

- CLI版なのでコンテキスト消費量が **見える**
- Claude Codeの全機能（ファイル操作、コマンド実行）が **使える**
- Zedの爆速表示が **活きる**

Agent Panel（GUI）にこだわる必要は全くなかったのです。

## 「ハッカーのコックピット」の完成

ターミナルを左側に配置し、エディタを右側に置く。このレイアウトが完成した瞬間、すべてが繋がりました。

```
┌──────────────────┬──────────────────┬─────────────┐
│                  │                  │             │
│ Claude Code CLI  │   Zed Editor     │ File Tree   │
│ (ターミナル)      │   (ファイル表示)  │ (右端)      │
│                  │                  │             │
│ 指示を出す        │   結果を確認する  │ 構造を把握   │
│ ↓               │   ↑              │             │
│ コンテキスト%表示  │   即時反映       │             │
│                  │                  │             │
└──────────────────┴──────────────────┴─────────────┘
```

**左が「脳」、中央が「体」、右が「地図」。**

![Zedのレイアウト：左にClaude Code CLI、中央にエディタ、右にファイルツリー](/images/Cursror2Zed.png)

左のCLIで指示を出すと、Claude Codeがファイルを修正します。中央のZedに即座に反映されます。右のファイルツリーでプロジェクト全体の構造を俯瞰できます。コンテキスト消費量はCLIの左下にそのまま表示されます。

Cursorでも同じことはできます。しかしCursorは「重い器」です。Zedはファイルの表示が一瞬で、余計なバックグラウンド処理がありません。

**エディタはただの「表示器」でいい。** コードを書かない私にとって、エディタに求めるのは軽さと速さだけ。Zedはその要件を完璧に満たします。

## settings.json：最終形（全文公開）

試行錯誤を経て、`~/.config/zed/settings.json` はこうなりました。

```jsonc
{
    // === AI関連：意図的に全部オフ ===
    "edit_predictions": {
        "provider": "none"          // コード補完は不要。書かないので。
    },
    "agent": {
        "enabled": false,           // Agent Panel（GUI）は使わない。CLIで十分。
        "dock": "left"
    },

    // === レイアウト：左にCLI、右にファイルツリー ===
    "terminal": {
        "dock": "left",             // ターミナルが左＝メインの作業場
        "font_family": "SF Mono",
        "font_size": 15,
        "line_height": "comfortable",
        "working_directory": "current_project_directory"  // cd不要
    },
    "project_panel": {
        "auto_reveal_entries": true,
        "dock": "right"             // ファイル一覧はターミナルの邪魔にならない右側に
    },

    // === エディタ基本設定 ===
    "theme": "Ayu Dark",
    "vim_mode": false,
    "soft_wrap": "editor_width",
    "ui_font_size": 16,
    "buffer_font_size": 16,
    "buffer_font_family": "SF Mono",
    "autosave": "on_focus_change",  // 保存を意識しない
    "format_on_save": "on",         // 保存時にコードを自動整形（インデントや空白を揃える）
    "tab_size": 4,
    "show_whitespaces": "none",

    // === 読みやすさ向上 ===
    "indent_guides": {
        "enabled": true,
        "coloring": "indent_aware"
    },
    "inlay_hints": { "enabled": true },
    "git": {
        "inline_blame": { "enabled": true }
    },

    // === 言語別設定 ===
    "languages": {
        "Swift":  { "tab_size": 4, "format_on_save": "on" },
        "Python": { "tab_size": 4, "format_on_save": "on" },
        "JSON":   { "tab_size": 2, "soft_wrap": "editor_width" }
    }
}
```

### 設定の意図を解説します

**なぜ `edit_predictions` を `none` にしたか：** 私はコードを書きません。補完候補がポップアップされると、レビュー中の集中が途切れるだけです。Claude Codeが書いたコードを「読む」ことに特化するなら、補完ノイズはゼロがベストです。

**なぜ `agent` を `false` にしたか：** ZedにはビルトインのAI機能（Agent Panel）がありますが、私はClaude Code CLIをターミナルから直接使います。Agent Panelはトークン消費量が表示されないという制限があり、CLIの方が情報量が多く制御しやすいためです。

**レイアウトの意図（ターミナル左、ファイルツリー右）：** 通常のエディタはファイルツリーが左にありますが、私のメイン作業場はターミナル（Claude Code CLI）です。一番使う場所を一番アクセスしやすい左に置きました。

**`format_on_save` とは：** ファイルを保存するタイミングで、コードのインデントや空白、改行などを自動的に整形してくれる機能です。言語ごとのフォーマッタ（Pythonならruff、SwiftならSwiftFormatなど）が設定されていれば、保存するだけでコードが綺麗になります。Claude Codeが生成したコードも、保存時に自動で整形されるので便利です。

### インストールした拡張機能（必要最小限の7個）

| 拡張 | 種別 | 用途 |
|:---|:---|:---|
| swift | 言語 | Swift/SwiftUI開発（sourcekit-lsp連携） |
| html | 言語 | HTML対応 |
| toml | 言語 | pyproject.toml等の編集 |
| dracula / tokyo-night / one-dark-pro / material-dark | テーマ | 4つ試して **Ayu Dark**（ビルトイン）に落ち着きました |

VSCodeの60,000以上の拡張と比べるとZedの拡張エコシステムは数百程度ですが、Claude Code CLIメインの構成では言語サポートとテーマがあれば十分でした。

## マルチ言語ワークスペースでの実用性

私は以下の4プロジェクトを1つのワークスペースで管理しています（プロジェクト名は仮名です）。

| プロジェクト | スタック | Zedでの対応 |
|:---|:---|:---|
| ogre-training-ios | Swift 6.0 / SwiftUI | Swift拡張 + sourcekit-lsp |
| hanma-dojo-ios | Swift 6.0 / SwiftUI | Swift拡張 + sourcekit-lsp |
| maximum-tournament-web | TypeScript / Next.js 16 | ビルトインTS/JSサポート |
| grappler-tools | Python / uv | ビルトインPythonサポート |

### Swift（iOS開発）

sourcekit-lspによるコード補完と定義ジャンプが動作します。ただしXcodeとの併用は必須です。ビルド・シミュレータ実行はXcode側で行い、コードの閲覧とClaude Codeへの指示出しはZed側で行うという分担になります。

### Python

ビルトインのPythonサポートが充実しています。`format_on_save` も問題なく動作しました。uv + pyproject.toml 構成との相性も良好です。

### TypeScript / Next.js

ビルトインのTypeScript/JavaScriptサポートで基本的な開発体験は得られます。ESLintやPrettierとの連携はVSCodeほどプラグインが充実していませんが、Claude Code CLIがフォーマットやリントも処理してくれるため、実用上の問題は感じていません。

## 並行開発：ウィンドウを分ければ `cd` は不要

Zedでは `Cmd + Shift + N` で新しいウィンドウを開けます。プロジェクトごとにウィンドウを分ければ、ターミナルは自動的にそのプロジェクトのルートで起動します。`cd` を打つ必要は一切ありません。

```
[Zed ウィンドウ1: ogre-training-ios]   [Zed ウィンドウ2: maximum-tournament-web]
┌──────────┬──────────┐          ┌──────────┬──────────┐
│ Claude   │ Swift    │          │ Claude   │ TypeScript│
│ Code CLI │ コード    │          │ Code CLI │ コード     │
└──────────┴──────────┘          └──────────┴──────────┘
```

2つのClaude Codeを同時に走らせ、片方でiOSアプリを修正しながら、もう片方でWebアプリを改修する。これがコードを書かない開発者の理想形です。

## Claude Code ACP vs CLI：使い分けの結論

ここで、Zed の Agent Panel（ACP経由）とターミナルCLIの使い分けを整理しておきます。

| 観点 | Agent Panel (ACP) | ターミナル CLI |
|:---|:---|:---|
| コンテキスト表示 | 非表示 | **表示あり** |
| ファイル変更のレビュー | マルチバッファで見やすい | ターミナル内のdiff表示 |
| Accept/Reject操作 | GUI で直感的 | `y/n` キー操作 |
| CLAUDE.md統合 | 対応 | 対応 |
| スラッシュコマンド | 対応 | 対応 |
| チェックポイント | 未対応 | **対応** |
| 過去スレッドの再開 | 不可 | **可能**（`--resume`） |

私の結論は **CLI メインで、必要に応じてACPを併用** です。コンテキストの可視性とチェックポイント機能が決め手でした。Agent Panelはマルチバッファでの変更レビューが見やすいので、大きな変更を俯瞰したいときに使い分けています。

## 移行で困ったこと・注意点

正直に書いておきます。

**拡張機能の少なさ：** VSCodeの豊富な拡張に慣れていると、最初は不安を感じます。ただし「Claude Code CLIがエディタの不足を補ってくれる」と気づいてからは気にならなくなりました。

**日本語入力：** Zedの日本語入力はまだ発展途上です。コード中のコメントやCLAUDE.mdの編集時に若干のもたつきを感じることがあります。ただし私のメイン入力先はターミナル（Claude Code CLI）なので、実用上の支障は限定的です。

**設定ファイルの独特さ：** ZedのsettingsはJSON形式ですがコメントが書ける（JSONC）という独特の仕様です。また、バージョンアップに伴ってキー構造が変わることがあります（例：`features.edit_prediction_provider` → `edit_predictions.provider`）。設定のバックアップは取っておくことをおすすめします。

## 正直な疑問：Zedである必要はあるのか？

ここまで書いておいて言うのもなんですが、**今の私の使い方だと、Zedである必然性は薄い** です。

「エディタ＝表示器、本体＝CLI」という構成なら、極端に言えばSublime Textでも、ターミナル＋vimでも成立します。Zedの売りであるAI統合（Agent Panel）を意図的にオフにしている時点で、Zedの目玉機能を使っていません。

それでもZedを選んでいる理由は3つあります。

**1. 「読む」体験が明確に良い。** 起動もファイル切替も一瞬です。sourcekit-lspの定義ジャンプ、Git inline blame、インデントガイドなど、コードを「読む」ためのサポートが軽快に動きます。Cursorでも同じ機能はありますが、それを142MBのメモリで実現できるのはZedだけです。

**2. Agent Panelは「未来への投資」。** 現時点ではトークン表示やチェックポイントが未対応ですが、Zed 1.0でマルチエージェントコラボレーションが実装されれば、CLIでは実現しにくい使い方が出てきます。今のうちにエディタとして手に馴染ませておく意味はあります。

**3. 「無駄がない」こと自体が価値。** Cursorの「使っていないAI機能がメモリを食っている」状態から、Zedの「使わないものはそもそも動いていない」状態になったことで、精神的な快適さが違います。これは非機能要件ですが、毎日使う道具では無視できません。

要するに、**今日のZedは「最速の表示器」として十分に価値があり、明日のZedはそれ以上になる可能性がある** — というのが現時点の評価です。

## 今日わかったこと

### エディタのAI機能は「CLI未満」になりつつある

ZedのAgent PanelもCursorのComposerも、確かに便利です。しかしClaude Code CLIの方が情報量が多く（コンテキスト消費量、思考プロセス、実行ログがすべて見える）、制御しやすい。

**GUIは「わかりやすさ」を提供しますが、CLIは「透明性」を提供します。** AIに仕事を任せるなら、何が起きているか見えることの方が重要です。

### 「重いエディタ」は過去の遺物

CursorやVSCodeは、人間がコードを書くことを前提に設計されています。コード補完、リファクタリング支援、デバッガ統合 — これらはすべて「人間が書く」前提の機能です。

コードをAIが書く時代に、エディタに求められるのは **「速く表示すること」** だけ。Zedの「余計なことをしない軽さ」は、この新しいパラダイムに最適です。

### AIツールの使い分けも重要なスキル

今日の迷走で一番助けられたのは、実はGeminiでした。Zedの仕様確認、レイアウトの提案、「標準モードに逃げるな」という判断 — これらはすべてGeminiとの対話から生まれました。

Claude Codeは「実行者」として最強ですが、「どの道具をどう使うか」という戦略的判断には別の視点が必要です。AIツールの使い分けも、個人開発の重要なスキルだと実感しました。

## 今後の期待

Zed 1.0（2026年春予定）に向けて、[公式ロードマップ](https://zed.dev/roadmap)には以下の機能が記載されています。

- **マルチエージェントコラボレーション：** 複数のモデルを同時に実行し、結果をレビューしてベストなものをマージ
- **インタラクティブノートブック：** データの可視化・操作をネイティブに
- **大規模リポジトリ最適化：** 特に大きなリポジトリでのパフォーマンス改善

また、Claude Code側の動向として、ACP経由でのHooksやPlan modeのサポートが追加予定とされています（コンテキスト資料の制限事項に「Plan mode は追加予定」と記載あり）。これらが実現すれば、Agent Panelの使い勝手がCLIに近づく可能性がありますが、正式なタイムラインは未公表です。

## まとめ

| 項目 | Cursor (Before) | Zed + CLI (After) |
|:---|:---|:---|
| 起動速度 | 遅い | 爆速 |
| メモリ消費 | 重い（独自AI常駐） | 軽い |
| Claude Code連携 | 拡張機能経由 | CLI直接実行 |
| コンテキスト表示 | 拡張では非表示 | CLIで表示 |
| 並行開発 | 可能だが重い | ウィンドウ分割で軽量 |
| AI機能 | 使っていない（無駄） | 使わない設計（無駄なし） |

**結論：エディタはただの「表示器」でいい。本体はCLIにある。**

CursorからZedへの移行は、単なるエディタの乗り換えではありませんでした。「GUIのAIチャット」から「CLIの自律エージェント」へ、開発スタイルそのものの転換です。

Zedは1.0前の今が試し始めるのにちょうどいいタイミングです。特にClaude Codeを既に使っている方は、ビルトインAIを全部切って「黒い画面」に振り切る構成を、ぜひ試してみてください。

---

:::message
**タイムライン（2026-02-11）**
- 午前 — Geminiとの対話でZed移行を決意
- 午後 — Zedインストール、Claude Codeに初期設定を構築させる
- 午後 — Agent Panel（GUI）でトークン非表示問題に直面
- 午後 — CLI版をZedターミナルで起動する最適解を発見
- 夕方 — テーマ・フォント・レイアウトの調整を完了
- 夜 — 「ハッカーのコックピット」レイアウト確立
:::

:::details settings.json の設定ポイントまとめ
- `edit_predictions.provider: "none"` — AI補完OFF。Claude Code CLIに任せる
- `agent.enabled: false` — Agent Panel（GUI）は使わない
- `terminal.dock: "left"` — ターミナルをメインの作業場に
- `terminal.working_directory: "current_project_directory"` — cd不要
- `project_panel.dock: "right"` — ファイル一覧は右側に退避
- `autosave: "on_focus_change"` — 保存操作を意識しない
- `format_on_save: "on"` — 保存時にコードを自動整形
:::
